#!/bin/tcsh -f
#Tyler Blazey, 2011.

#######
#Usage#
#######

set program = $0:t
if ($#argv == 0) then
	echo ""
	echo "${program}: A basic wrapper for FSL's field map tools"
	echo ""
	echo "Usage:"
	echo ""
	echo "Required Arguments:"
	echo "	-m: field map magnitude image"
	echo "	-p: field map phase image"
	echo "	-e: EPI to unwarp."
	echo "	-dwell: EPI dwell time. In milliseconds"
	echo "	-te: EPI echo time. In milliseconds"
	echo "	-delta: Difference between field map echo times. In milleseconds."
	echo ""
	echo "Optional Arguments:" 
	echo "	-reg: Field map regulation. Takes despike, smooth, median, or none. Default is despike."
	echo "	-frame:	EPI frame to extract for registration. Default is 0."
	echo "	-o: Outpath. Default is unwarp"
	echo "	-r: Outroot. Default is blank"
	echo "	-thresh: Signal loss threshhold. Default is 0.1"
	echo "	-dthresh: Despike threshhold. For use with -reg despike. Default is 2.1"
	echo " 	-mm3: Size of kernel to use with -reg smooth. Default is 5"
	echo " 	-dir: Direction of epi unwarp. Default is y-. Takes x,x-,y,y-,z,z-"
	echo "	-nounwrap: Turn off phase unwrapping. On by default."
	echo "	-dtimc: Due eddy correction for dti input. Will only resample once."
	echo "	-boldmc: Apply mcflirt to bold input. Will only resample once."
	echo " 	-nomask: Do not use mask when applying motion correction."
	echo "	-epibet: BET fractional intensity threshold for EPI. Default is .2"
	echo "	-debug: Turn on set echo."
	echo ""
	echo "Tips:"
	echo "	Standard CAP DTI parameters:  Dwell Time=.98ms, Echo Time=112ms."
	echo "	Standard CAP BOLD parameters: Dwell Time=.47ms, Echo Time=27ms."
	echo "	Standard CAP Field Map delta TE=2.46ms."
	echo ""	
	exit
endif

#################
#Parse Arguments#
#################

while ($#argv > 0) 
	set flag = $argv[1]; shift;
	switch ($flag)
		case -m:
			set mag = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -e:
			set epi = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -p:
			set phase = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -o:
			set outpath = $argv[1]; shift; breaksw;
		case -r:
			set outroot = "$argv[1]_"; shift; breaksw;
		case -te:
			set te = `echo "$argv[1]/1000" | bc -l`; shift; breaksw;
		case -dwell:
			set dwell = `echo "$argv[1]/1000" | bc -l`; shift; breaksw;
		case -delta:
			set delta = `echo "$argv[1]/1000" | bc -l`; shift; breaksw;
		case -thresh
			set thresh = `echo "1-$argv[1]" | bc -l` ; shift; breaksw;
		case -frame:
			set frame = $argv[1]; shift; breaksw;
		case -reg:
			set reg = $argv[1]; shift; breaksw;
		case -dthresh:
			set dthresh = $argv[1]; shift; breaksw;
		case -mm3:
			set mm3 = $argv[1]; shift; breaksw;
		case -dir:
			set dir = $argv[1]; shift; breaksw;
		case -nounwrap:
			set unwrap = 0; breaksw;
		case -dtimc:
			set dtimc = 1; breaksw;
		case -boldmc:
			set boldmc = 1; breaksw;
		case -nomask:
			set mask = ""; breaksw
		case -epibet:
			set epibet = $argv[1]; shift; breaksw;
		case -debug:
			set echo; breaksw;
		default:
			echo "Option $flag not recognized. See usage."
			exit 1
	endsw
end

#############################
#Check options, set defaults#
#############################

#Check to make sure all required options have been set
if ( $?mag == 0 || $?epi == 0 || $?phase == 0  || $?dwell == 0 || $?te == 0 || $?delta == 0  ) then
	echo "Missing required arguments. See usage"
	exit 1
endif

#Set defaults
if ($?frame == 0)	set frame = 0; 
if ($?outroot == 0)	set outroot = ""
if ($?thresh == 0)	set thresh = 0.9
if ($?outpath == 0) set outpath = "unwarp"
if (! -d $outpath)	mkdir $outpath
if ($?reg == 0) set reg = "despike"
if ($reg == "despike" && $?dthresh == 0) set dthresh = 2.1
if ($reg == "smooth" && $?mm3 == 0) set mm3 = 5
if ($?dir == 0) set dir = "y-"
if ($?unwrap == 0) set unwrap = 1
if ($?epibet == 0 ) set epibet = .2
set FSL = $FSLDIR/bin

#Check to make sure -reg is set correctly
set reg_options = ( "smooth" "median" "none" "despike"); echo $reg_options | grep -qw $reg;
if ( $? == 1 ) then
	echo "-reg option $reg not known. See usage"
	exit 1
endif

#Check to see if -dir is set correctly
set dir_options = ( "x" "x-" "y" "y-" "z" "z-"); echo $dir_options | grep -qw $dir;
if ( $? == 1 ) then
	echo "-dir option $dir not known. See usage"
	exit 1
endif

#####################################
#Preproc, Unit Conversion, Unwraping#
#####################################

#Copy images over
$FSL/imcp $mag ${outpath}/${outroot}mag; $FSL/imcp $epi ${outpath}/${outroot}epi
$FSL/imcp $phase ${outpath}/${outroot}phase
cd $outpath

#Convert field map to radians
set range = `fslstats ${outroot}phase -R`.
if ( $range[1] == -4096.000000 && $range[2] == 4092.000000 ) then
	$FSL/fslmaths ${outroot}phase -div 4096 -mul 3.14159265 ${outroot}phase_rad -odt float
else if ( $range[1] == 0.000000 && $range[2] == 4094.000000 ) then
	$FSL/fslmaths ${outroot}phase -sub 2047 -div 2047 -mul 3.14159265 ${outroot}phase_rad -odt float		
else
	echo "Range of phase map is not -4096.000000 to 4092.000000. Exiting..."
	exit 1
endif

#Create brain mask for magnitude
$FSL/bet ${outroot}mag ${outroot}mag_brain -f 0.3 -m -R

#If user wants, unwrap phase with prelude.
if ($unwrap == 1) then
	$FSL/prelude -p ${outroot}phase_rad -a ${outroot}mag -o ${outroot}phase_rad_unwrap \
				 -m ${outroot}mag_brain_mask
endif

#Convert to radians/second
$FSL/fslmaths ${outroot}phase_rad_unwrap -div $delta ${outroot}phase_rad_unwrap_secs

###############
#Brain Masking#
###############

#Extract epi frame, then brain extract
$FSL/fslroi ${outroot}epi ${outroot}epi_${frame} $frame 1
$FSL/bet ${outroot}epi_${frame} ${outroot}epi_${frame}_brain -m -f $epibet -R

#Create inverted field map brain mask
$FSL/fslmaths ${outroot}phase_rad_unwrap_secs -abs -bin -mas ${outroot}mag_brain_mask -mul -1 \
			  -add 1 -bin ${outroot}phase_rad_unwrap_secs_inv_brain_mask
		 
#Cluster inverted brain mask
$FSL/cluster -i ${outroot}phase_rad_unwrap_secs_inv_brain_mask -t 0.5 --no_table \
			 -o ${outroot}phase_rad_unwrap_secs_inv_brain_mask_clust
		
#Save intensity of largest cluster 
set max = `$FSL/fslstats ${outroot}phase_rad_unwrap_secs_inv_brain_mask_clust -R | awk '{print $2}'`
#Threshhold the image by max, then invert again. Get a new, tighter brain mask.
$FSL/fslmaths ${outroot}phase_rad_unwrap_secs_inv_brain_mask_clust -thr $max -bin -mul -1 -add 1 \
			  -bin -mas ${outroot}mag_brain_mask ${outroot}mag_brain_mask
		 
#Use the new brain mask on the field map
$FSL/fslmaths ${outroot}phase_rad_unwrap_secs -mas ${outroot}mag_brain_mask \
			  ${outroot}phase_rad_unwrap_secs

#Get a 50% brain mask
set fifty = `$FSL/fslstats ${outroot}mag_brain -P 98 | awk '{print ( $1 / 2 ) }'`
$FSL/fslmaths ${outroot}mag_brain -thr $fifty -bin ${outroot}mag_brain_fifty_mask

#Erode the original brain mask
$FSL/fslmaths ${outroot}mag_brain_mask -ero ${outroot}mag_brain_mask_eroded

#Add eroded and fifty masks
$FSL/fslmaths ${outroot}mag_brain_mask_eroded -add ${outroot}mag_brain_fifty_mask -thr 0.5 \
		 	  -bin ${outroot}mag_brain_mask
		 
#Mask the field map again
$FSL/fslmaths ${outroot}phase_rad_unwrap_secs -mas ${outroot}mag_brain_mask \
			  ${outroot}phase_rad_unwrap_secs

#Erode brain mask again
$FSL/fslmaths ${outroot}mag_brain_mask -ero ${outroot}mag_brain_mask_eroded

###########
#Filtering#
###########

#Create filter
switch ($reg)
	case "despike":
		$FSL/fugue --loadfmap=${outroot}phase_rad_unwrap_secs \
				   --mask=${outroot}mag_brain_mask --despike --despikethreshold=$dthresh \
				   --savefmap=${outroot}phase_rad_unwrap_secs_filter_${reg}
		breaksw
	case "smooth":
		$FSL/fugue --loadfmap=${outroot}phase_rad_unwrap_secs --mask=${outroot}mag_brain_mask \
		     	   --savefmap=${outroot}phase_rad_unwrap_secs_filter_${reg}-s $mm3
		breaksw
	case "median":
		$FSL/fugue --loadfmap=${outroot}phase_rad_unwrap_secs --mask=${outroot}mag_brain_mask -m \
		           --savefmap=${outroot}phase_rad_unwrap_secs_filter_${reg} 
		breaksw
	case "none":
		$FSL/imcp ${outroot}phase_rad_unwrap_secs ${outroot}phase_rad_unwrap_secs_filter_${reg} 
endsw

#Apply the filter to brain edges
$FSL/fslmaths ${outroot}phase_rad_unwrap_secs_filter_${reg} -sub ${outroot}phase_rad_unwrap_secs \
			  -mas ${outroot}mag_brain_mask_eroded -add \
			  ${outroot}phase_rad_unwrap_secs ${outroot}phase_rad_unwrap_secs

#Shift median to 0
set median = `$FSL/fslstats ${outroot}phase_rad_unwrap_secs -k ${outroot}mag_brain_mask -P 50`
$FSL/fslmaths ${outroot}phase_rad_unwrap_secs -sub $median ${outroot}phase_rad_unwrap_secs

#Estimate signal loss from fieldmap. Range goes from 0 (no signal) to 1 (full signal)
$FSL/sigloss -i ${outroot}phase_rad_unwrap_secs --te=${te} -m ${outroot}mag_brain_mask \
			 -s ${outroot}signal_loss

#Multiply mag brain by signal loss image. Will result in a mag brain with areas of signal loss.
$FSL/fslmaths ${outroot}signal_loss -mul ${outroot}mag_brain ${outroot}mag_brain_signal_lossed \
			  -odt float

#####################################
#FUGUE, Registration, Transformation#
#####################################

#Run fugue on the signal lossed magnitude image. Will distort it according to the field map. 
#Then do the same thing for the signal_loss fmap image.
$FSL/fugue -i ${outroot}mag_brain_signal_lossed --loadfmap=${outroot}phase_rad_unwrap_secs \
	  --mask=${outroot}mag_brain_mask -w ${outroot}mag_brain_signal_lossed_distorted \
	  --nokspace --unwarpdir=$dir --dwell=$dwell 
$FSL/fugue -i ${outroot}signal_loss --loadfmap=${outroot}phase_rad_unwrap_secs  --dwell=$dwell \
	  	   -w ${outroot}signal_loss_distorted --nokspace --unwarpdir=$dir \
	  	   --mask=${outroot}mag_brain_mask

#Threshhold the distorted signal loss brain according to user chosen signal loss threshhold
$FSL/fslmaths ${outroot}signal_loss_distorted -thr $thresh ${outroot}signal_loss_distorted

#Register the distorted magnitude to the distorted functional. Output a transformation file only.
#Use the threshholded signal loss brain as weighting (areas with 0 will be ignored)
$FSL/flirt -in ${outroot}mag_brain_signal_lossed_distorted -ref ${outroot}epi_${frame}_brain \
	  -omat ${outroot}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain.mat -dof 6 \
	  -inweight ${outroot}signal_loss_distorted

#Apply the created transform to the field map and brain mask
$FSL/flirt -in ${outroot}phase_rad_unwrap_secs -ref ${outroot}epi_${frame}_brain \
	  -init ${outroot}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain.mat \
	  -applyxfm -out ${outroot}phase_rad_unwrap_secs_to_${outroot}epi_${frame}_brain
$FSL/flirt -in ${outroot}mag_brain_mask -ref ${outroot}epi_${frame}_brain \
	  -init ${outroot}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain.mat \
	  -applyxfm -out ${outroot}mag_brain_mask_to_${outroot}epi_${frame}_brain 
#Rebinarize mask. Using 0.4 to avoid brain erosion.
$FSL/fslmaths ${outroot}mag_brain_mask_to_${outroot}epi_${frame}_brain -thr 0.4 -bin \
			  ${outroot}mag_brain_mask_to_${outroot}epi_${frame}_brain

#Run fugue using the registerted field map on the distorted epi. 
#Will undistort the first frame epi and save the shift map that does this.
$FSL/fugue --loadfmap=${outroot}phase_rad_unwrap_secs_to_${outroot}epi_${frame}_brain \
	  --dwell=$dwell --mask=${outroot}mag_brain_mask_to_${outroot}epi_${frame}_brain \
	  -i ${outroot}epi_${frame} -u ${outroot}epi_${frame}_undist --unwarpdir=$dir \
	  --saveshift=${outroot}epi_${frame}_brain_undist_shift

#Convert the shiftwarp to an absolute warp
$FSL/convertwarp -s ${outroot}epi_${frame}_brain_undist_shift \
		    -o ${outroot}epi_${frame}_brain_undist_shift_warp -r ${outroot}epi_${frame}_brain \
	        --shiftdir=$dir
	        
###################
#Motion Correction#
###################

if ( $?dtimc == 1  || $?boldmc == 1 ) then
	
	#Setup mask if not already done
	if ( $?mask == 0 ) set mask = "-m ${outroot}mag_brain_mask_to_${outroot}epi_${frame}_brain"
	
	$FSL/fslsplit ${outroot}epi ${outroot}epi_tmp
	foreach tmp ( ${outroot}epi_tmp* )
		
		#Create correct pre matrices
		if ( $?dtimc == 1 ) then
			set tmp = `$FSL/remove_ext $tmp`
			echo "processing $tmp" >> ${outroot}eddycorrect.log
			echo "" >> ${outroot}eddycorrect.log
			$FSL/flirt -in $tmp -ref ${outroot}epi_${frame} -nosearch -omat ${tmp}.mat \
						-paddingsize 1
			set pre = "${tmp}.mat"
			echo "Final Result:" >> ${outroot}eddycorrect.log
			cat $pre >> ${outroot}eddycorrect.log
			echo "" >> ${outroot}eddycorrect.log
		else
			if ( $?notfirst == 0 ) then
				$FSL/mcflirt -refvol ${frame} -mats -in ${outroot}epi -plots -rmsrel \
							 -rmsabs -out ${outroot}mcf
			endif
			set notfirst = 1
			set tmp = `$FSL/remove_ext $tmp`
			set num = `echo $tmp | grep -o "tmp.*[0-9]" | sed 's/tmp//g'`
			set pre = "${outroot}mcf.mat/MAT_${num}"
		endif

		#Apply motion correction
		$FSL/applywarp -i $tmp -o ${tmp}_undist_mcf -r ${outroot}epi --abs $mask \
		          	   -w ${outroot}epi_${frame}_brain_undist_shift_warp --premat=$pre
	end
	
	$FSL/fslmerge -t ${outroot}epi_undist_mcf ${outroot}epi_tmp*_undist_mcf.nii.gz
	rm ${outroot}epi_tmp*	
endif
		