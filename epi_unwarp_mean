#!/bin/tcsh -f
#Tyler Blazey, 2011.

if ( $?FSLDIR == 0 ) then
	echo "FSLDIR environment variable needs to be set before running scripts."
	exit 1
else
	set FSL = "$FSLDIR/bin"
endif

#######
#Usage#
#######

set program = $0:t
if ($#argv == 0) then
	echo ""
	echo "${program}: A basic wrapper for FSL's field map tools"
	echo ""
	echo "Usage:"
	echo ""
	echo "Required Arguments:"
	echo "	-m: field map magnitude image"
	echo "	-p: field map phase image"
	echo "	-e: EPI to unwarp."
	echo "	-dwell: EPI dwell time/echo spacing. Divide by acceleration factor if necessary. In milliseconds"
	echo "	-te: EPI echo time. In milliseconds"
	echo "	-delta: Difference between field map echo times. In milleseconds."
	echo ""
	echo "Optional Arguments:" 
	echo "	-magmask: Specify magnitude mask image instead of estimating."
	echo "	-meanmap: Turns off conversion to radians and phase unwrapping."
	echo "	-reg: Field map regulation. Takes despike, smooth, median, or none. Default is despike."
	echo "	-frame:	EPI frame to extract for registration. Default is 0."
	echo "	-o: Outpath. Default is unwarp"
	echo "	-r: Outroot. Default is blank"
	echo "	-thresh: Signal loss threshhold. Default is 0.1"
	echo "	-dthresh: Despike threshhold. For use with -reg despike. Default is 2.1"
	echo " 	-mm3: Size of kernel to use with -reg smooth. Default is 5"
	echo " 	-dir: Direction of epi unwarp. Default is y-. Takes x,x-,y,y-,z,z-"
	echo "	-nounwrap: Turn off phase unwrapping. On by default."
	echo "	-dtimc: Due eddy correction for dti input. Will only resample once."
	echo "	-boldmc: Apply mcflirt to bold input. Will only resample once."
	echo " 	-nomask: Do not use mask when applying motion correction."
	echo "	-epibet: BET fractional intensity threshold for EPI. Default is .2"
	echo " 	-dil: Dilate magnitude brain mask before applying to motion corrected EPI."
	echo "	-debug: Turn on set echo."
	echo ""
	echo "Tips:"
	echo "	Standard CAP DTI parameters:  Dwell Time=.98ms, Echo Time=112ms."
	echo "	Standard CAP BOLD parameters: Dwell Time=.47ms, Echo Time=27ms."
	echo "	Standard CAP Field Map delta TE=2.46ms."
	echo ""	
	exit
endif

#################
#Parse Arguments#
#################

while ($#argv > 0) 
	set flag = $argv[1]; shift;
	switch ($flag)
		case -m:
			set imcheck = `$FSL/imtest $argv[1]`
			if ( $imcheck == 0 ) then
				echo "Cannot find magnitude image at $argv[1]."
				exit 1
			endif
			set mag = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -e:
			set imcheck = `$FSL/imtest $argv[1]`
			if ( $imcheck == 0 ) then
				echo "Cannot find epi image at $argv[1]."
				exit 1
			endif
			set epi = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -p:
			set imcheck = `$FSL/imtest $argv[1]`
			if ( $imcheck == 0 ) then
				echo "Cannot find phase image at $argv[1]."
				exit 1
			endif
			set phase = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -magmask:
			set imcheck = `$FSL/imtest $argv[1]`
			if ( $imcheck == 0 ) then
				echo "Cannot find magnitude mask image at $argv[1]."
				exit 1
			endif
			set magmask = `$FSLDIR/bin/remove_ext $argv[1]`; shift; breaksw;
		case -meanmap:
			set meanmap = 1; breaksw;
		case -o:
			set outpath = $argv[1]; shift; breaksw;
		case -r:
			set outroot = "$argv[1]_"; shift; breaksw;
		case -te:
			set te = `echo "$argv[1]/1000" | bc -l`; shift; breaksw;
		case -dwell:
			set dwell = `echo "$argv[1]/1000" | bc -l`; shift; breaksw;
		case -delta:
			set delta = `echo "$argv[1]/1000" | bc -l`; shift; breaksw;
		case -thresh:
			set thresh = `echo "1-$argv[1]" | bc -l` ; shift; breaksw;
		case -frame:
			set frame = $argv[1]; shift; breaksw;
		case -reg:
			set reg = $argv[1]; shift; breaksw;
		case -dthresh:
			set dthresh = $argv[1]; shift; breaksw;
		case -mm3:
			set mm3 = $argv[1]; shift; breaksw;
		case -dir:
			set dir = $argv[1]; shift; breaksw;
		case -nounwrap:
			set nounwrap = 1; breaksw;
		case -dtimc:
			set dtimc = 1; breaksw;
		case -boldmc:
			set boldmc = 1; breaksw;
		case -nomask:
			set nomask = 1; breaksw
		case -epibet:
			set epibet = $argv[1]; shift; breaksw;
		case -dil:
			set dil = $argv[1]; breaksw;
		case -debug:
			set echo; breaksw;
		default:
			echo "Option $flag not recognized. See usage."
			exit 1
	endsw
end

#############################
#Check options, set defaults#
#############################

#Check to make sure all required options have been set
if ( $?mag == 0 || $?epi == 0 || $?phase == 0  || $?dwell == 0 || $?te == 0 || $?delta == 0  ) then
	echo "Missing required arguments. See usage"
	exit 1
endif

#Set defaults
if ($?frame == 0)	set frame = 0; 
if ($?outpath == 0) set outpath = "unwarp"
if (! -d $outpath)	mkdir $outpath
if ($?outroot == 0)	set outroot = ""
if ($?thresh == 0)	set thresh = 0.9
if ($?reg == 0) set reg = "despike"
if ($reg == "despike" && $?dthresh == 0) set dthresh = 2.1
if ($reg == "smooth" && $?mm3 == 0) set mm3 = 5
if ($?dir == 0) set dir = "y-"
if ($?epibet == 0 ) set epibet = .2

#Check to make sure -reg is set correctly
set reg_options = ( "smooth" "median" "none" "despike"); echo $reg_options | grep -qw $reg;
if ( $? == 1 ) then
	echo "-reg option $reg not known. See usage"
	exit 1
endif

#Check to see if -dir is set correctly
set dir_options = ( "x" "x-" "y" "y-" "z" "z-"); echo $dir_options | grep -qw $dir;
if ( $? == 1 ) then
	echo "-dir option $dir not known. See usage"
	exit 1
endif

#####################################
#Preproc, Unit Conversion, Unwraping#
#####################################
set out = $outpath/$outroot; set pout = ${outpath}/${outroot}phase

#Copy images over
$FSL/imcp $mag ${out}mag; $FSL/imcp $epi ${out}epi; $FSL/imcp $phase $pout

if ( $?meanmap == 0 ) then 
	#Convert field map to radians
	set range = `fslstats ${pout} -R`.
	if ( $range[1] == -4096.000000 && $range[2] == 4092.000000 ) then
		$FSL/fslmaths ${pout} -div 4096 -mul 3.14159265 ${pout}_rad -odt float
	else if ( $range[1] == 0.000000 && $range[2] == 4094.000000 ) then
		$FSL/fslmaths ${pout} -sub 2047 -div 2047 -mul 3.14159265 ${pout}_rad -odt float
	else if ( $range[1] == 0.000000 && $range[2] == 4095.000000 ) then
		$FSL/fslmaths ${pout} -sub 2047.5 -div 2047.5 -mul 3.14159265 ${pout}_rad -odt float
	else
		echo "Phase map is not within expected range. Exiting..."
		exit 1
	endif
	set pout = ${pout}_rad
endif

#Create brain mask for magnitude
if ( $?magmask == 0 ) then
	$FSL/bet ${out}mag ${out}mag_brain -f 0.3 -m -R
else
	$FSL/imcp $magmask ${out}mag_brain_mask
	$FSL/fslmaths ${out}mag -mas ${out}mag_brain_mask ${out}mag_brain
endif
	
#If user wants, unwrap phase with prelude.
if ( $?unwrap == 0 && $?meanmap == 0  ) then
	$FSL/prelude -p ${pout} -a ${out}mag -o ${pout}_unwrap
	set pout = ${pout}_unwrap
endif

#Convert to radians/second
$FSL/fslmaths ${pout} -div $delta ${pout}_secs
set pout = ${pout}_secs

###############
#Brain Masking#
###############

#Extract epi frame, then brain extract
$FSL/fslroi ${out}epi ${out}epi_${frame} $frame 1
$FSL/bet ${out}epi_${frame} ${out}epi_${frame}_brain -m -f $epibet -R

#Create inverted field map brain mask
$FSL/fslmaths ${pout} -abs -bin -mas ${out}mag_brain_mask -mul -1 -add 1 -bin ${pout}_inv_brain_mask
		 
#Cluster inverted brain mask
$FSL/cluster -i ${pout}_inv_brain_mask -t 0.5 --no_table -o ${pout}_inv_brain_mask_clust
		
#Save intensity of largest cluster 
set max = `$FSL/fslstats ${pout}_inv_brain_mask_clust -R | awk '{print $2}'`
#Threshhold the image by max, then invert again. Get a new, tighter brain mask.
$FSL/fslmaths ${pout}_inv_brain_mask_clust -thr $max -bin -mul -1 -add 1 -bin \
			  -mas ${out}mag_brain_mask ${out}mag_brain_mask
		 
#Use the new brain mask on the field map
$FSL/fslmaths ${pout} -mas ${out}mag_brain_mask ${pout}_masked
set pout = ${pout}_masked

#Get a 50% brain mask
set fifty = `$FSL/fslstats ${out}mag_brain -P 98 | awk '{print ( $1 / 2 ) }'`
$FSL/fslmaths ${out}mag_brain -thr $fifty -bin ${out}mag_brain_fifty_mask

#Erode the original brain mask
$FSL/fslmaths ${out}mag_brain_mask -ero ${out}mag_brain_mask_eroded

#Add eroded and fifty masks
$FSL/fslmaths ${out}mag_brain_mask_eroded -add ${out}mag_brain_fifty_mask -thr 0.5 \
		 	  -bin ${out}mag_brain_mask
		 
#Mask the field map again
$FSL/fslmaths ${pout} -mas ${out}mag_brain_mask ${pout}


#Erode brain mask again
$FSL/fslmaths ${out}mag_brain_mask -ero ${out}mag_brain_mask_eroded

###########
#Filtering#
###########

#Create filter
set filter = ${pout}_filter_${reg}
switch ($reg)
	case "despike":
		$FSL/fugue --loadfmap=${pout} --mask=${out}mag_brain_mask --despike \
				   --despikethreshold=$dthresh --savefmap=${filter}
		breaksw
	case "smooth":
		$FSL/fugue --loadfmap=${pout} --mask=${out}mag_brain_mask -s $mm3 \
		     	   --savefmap=${filter}
		breaksw
	case "median":
		$FSL/fugue --loadfmap=${pout} --mask=${out}mag_brain_mask -m \
		           --savefmap=${filter}
		breaksw
	case "none":
		$FSL/imcp ${pout} $filter 
endsw

#Apply the filter to brain edges
$FSL/fslmaths ${filter} -sub ${pout} -mas ${out}mag_brain_mask_eroded -add ${pout} ${pout}_filtered
set pout = ${pout}_filtered

#Shift median to 0
set median = `$FSL/fslstats ${pout} -k ${out}mag_brain_mask -P 50`
$FSL/fslmaths ${pout} -sub $median ${pout}_norm
set pout = ${pout}_norm

#Estimate signal loss from fieldmap. Range goes from 0 (no signal) to 1 (full signal)
$FSL/sigloss -i ${pout} --te=${te} -m ${out}mag_brain_mask -s ${out}signal_loss

#Multiply mag brain by signal loss image. Will result in a mag brain with areas of signal loss.
$FSL/fslmaths ${out}signal_loss -mul ${out}mag_brain ${out}mag_brain_signal_lossed -odt float

#####################################
#FUGUE, Registration, Transformation#
#####################################

#Run fugue on the signal lossed magnitude image. Will distort it according to the field map. 
#Then do the same thing for the signal_loss fmap image.
$FSL/fugue -i ${out}mag_brain_signal_lossed --loadfmap=${pout} --mask=${out}mag_brain_mask \
		   -w ${out}mag_brain_signal_lossed_distorted --nokspace --unwarpdir=$dir --dwell=$dwell 
$FSL/fugue -i ${out}signal_loss --loadfmap=${pout} --dwell=$dwell -w ${out}signal_loss_distorted  \
		   --nokspace --unwarpdir=$dir --mask=${out}mag_brain_mask

#Threshhold the distorted signal loss brain according to user chosen signal loss threshhold
$FSL/fslmaths ${out}signal_loss_distorted -thr $thresh ${out}signal_loss_distorted

#Register the distorted magnitude to the distorted functional. Output a transformation file only.
#Use the threshholded signal loss brain as weighting (areas with 0 will be ignored)
$FSL/flirt -in ${out}mag_brain_signal_lossed_distorted -ref ${out}epi_${frame}_brain \
	  	   -omat ${out}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain.mat -dof 6 \
	       -out ${out}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain \
	       -inweight ${out}signal_loss_distorted

#Apply the created transform to the field map
$FSL/flirt -in ${pout} -ref ${out}epi_${frame}_brain -applyxfm \
	  -init ${out}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain.mat \
	  -out ${pout}_to_${outroot}epi_${frame}_brain
set pout = ${pout}_to_${outroot}epi_${frame}_brain

#Apply transform to mask and then rebinarize
$FSL/flirt -in ${out}mag_brain_mask -ref ${out}epi_${frame}_brain \
	  -init ${out}mag_brain_signal_lossed_distorted_to_${outroot}epi_${frame}_brain.mat \
	  -applyxfm -out ${out}mag_brain_mask_to_${outroot}epi_${frame}_brain 
$FSL/fslmaths ${out}mag_brain_mask_to_${outroot}epi_${frame}_brain -thr 0.5 -bin \
			  ${out}mag_brain_mask_to_${outroot}epi_${frame}_brain
			  
#If user wants, dilate brain mask slightly in order to prevent erosion
if ( $?dil == 1 ) then
	$FSL/fslmaths ${out}mag_brain_mask_to_${outroot}epi_${frame}_brain -dilM -dilM -ero \
				  ${out}mag_brain_mask_to_${outroot}epi_${frame}_brain
endif

#Run fugue using the registerted field map on the distorted epi. 
#Will undistort the first frame epi and save the shift map that does this.
$FSL/fugue --loadfmap=${pout} --dwell=$dwell -u ${out}epi_${frame}_undist --unwarpdir=$dir \
	  	   -i ${out}epi_${frame} --saveshift=${out}epi_${frame}_undist_shift \
	       --mask=${out}mag_brain_mask_to_${outroot}epi_${frame}_brain

#Convert the shiftwarp to an absolute warp
$FSL/convertwarp -s ${out}epi_${frame}_undist_shift -r ${out}epi_${frame} --shiftdir=$dir \
		    	 -o ${out}epi_${frame}_undist_shift_warp 
	        
###################
#Motion Correction#
###################

if ( $?dtimc == 1  || $?boldmc == 1 ) then
	
	#Setup mask if not already done
	if ( $?nomask == 1 ) then
		set mask = ""
	else
		set mask = "--mask=${out}mag_brain_mask_to_${outroot}epi_${frame}_brain"
	endif
	
	if ( $?meanmap == 0 ) then
		$FSL/fslsplit ${out}epi ${out}epi_tmp
		foreach tmp ( ${out}epi_tmp* )
		
			#Create correct pre matrices
			if ( $?dtimc == 1 ) then
				set tmp = `$FSL/remove_ext $tmp`
				echo "processing $tmp" >> ${out}eddycorrect.log
				echo "" >> ${out}eddycorrect.log
				$FSL/flirt -in $tmp -ref ${out}epi_${frame} -nosearch -omat ${tmp}.mat \
						   -paddingsize 1
				set pre = "${tmp}.mat"
				echo "Final Result:" >> ${out}eddycorrect.log
				cat $pre >> ${out}eddycorrect.log
				echo "" >> ${out}eddycorrect.log
			else
				if ( $?notfirst == 0 ) then
					$FSL/mcflirt -reffile ${out}epi_${frame} -in ${out}epi -plots -rmsrel \
							 	 -rmsabs -mats -out ${out}mcf
				endif
				set notfirst = 1
				set tmp = `$FSL/remove_ext $tmp`
				set num = `echo $tmp | grep -o "tmp.*[0-9]" | sed 's/tmp//g'`
				set pre = "${out}mcf.mat/MAT_${num}"
			endif
		
			#Apply motion correction
			$FSL/applywarp -i $tmp -o ${tmp}_mcf_undist -r ${out}epi --abs $mask \
		          	  	   -w ${out}epi_${frame}_undist_shift_warp --premat=$pre
		end
	
		$FSL/fslmerge -t ${out}epi_mcf_undist ${out}epi_tmp*_mcf_undist.nii.gz
		rm ${out}epi_tmp*	
	else
		$FSL/mcflirt -reffile ${out}epi_${frame} -in ${out}epi -plots -rmsrel -rmsabs -mats \
					 -out ${out}mcf
		$FSL/fugue --loadfmap=${pout} --dwell=$dwell -i ${out}mcf -u ${out}epi_mcf_undist \
			  --unwarpdir=$dir $mask
	endif
else
	$FSL/fugue --loadfmap=${pout} --dwell=$dwell -u ${out}epi_undist --unwarpdir=$dir \
	  	   	   -i ${out}epi --mask=${out}mag_brain_mask_to_${outroot}epi_${frame}_brain
endif
		